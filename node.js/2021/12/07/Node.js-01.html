<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>[Node.js] 개념 이해하기 | IT 데이터베이스</title>
<meta name="generator" content="Jekyll v4.2.2">
<meta property="og:title" content="[Node.js] 개념 이해하기">
<meta name="author" content="GitHub User">
<meta property="og:locale" content="en_US">
<meta name="description" content="Node.js란">
<meta property="og:description" content="Node.js란">
<link rel="canonical" href="/jekyll-theme-yat/node.js/2021/12/07/Node.js-01.html">
<meta property="og:url" content="/jekyll-theme-yat/node.js/2021/12/07/Node.js-01.html">
<meta property="og:site_name" content="IT 데이터베이스">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2021-12-07T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="[Node.js] 개념 이해하기">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"GitHub User"},"dateModified":"2021-12-07T00:00:00+00:00","datePublished":"2021-12-07T00:00:00+00:00","description":"Node.js란","headline":"[Node.js] 개념 이해하기","mainEntityOfPage":{"@type":"WebPage","@id":"/jekyll-theme-yat/node.js/2021/12/07/Node.js-01.html"},"url":"/jekyll-theme-yat/node.js/2021/12/07/Node.js-01.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/jekyll-theme-yat/assets/css/main.css">
  <link rel="stylesheet" href="/jekyll-theme-yat/assets/css/image-popup.css">

  <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="/jekyll-theme-yat/assets/js/main.js"></script>
  <script src="/jekyll-theme-yat/assets/js/zooming.min.js"></script><link type="application/atom+xml" rel="alternate" href="/jekyll-theme-yat/feed.xml" title="IT 데이터베이스">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
</head>
<body>





































































































































<header class="site-header site-header-transparent" role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/jekyll-theme-yat/">
  <img class="site-favicon" title="IT 데이터베이스" src="" onerror="this.style.display='none'">
  IT 데이터베이스
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/jekyll-theme-yat/about.html">ABOUT</a><a class="page-link" href="/jekyll-theme-yat/archives.html">ARCHIVES</a><a class="page-link" href="/jekyll-theme-yat/categories.html">CATEGORIES</a><a class="page-link" href="/jekyll-theme-yat/">HOME</a><a class="page-link" href="/jekyll-theme-yat/tags.html">TAGS</a>









<span class="page-link">



<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="French">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: 'en',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  // Links to cross-origin destinations are unsafe
  var gll = document.getElementsByClassName('goog-logo-link')[0];
  if (gll) {
    gll.setAttribute('rel', 'noopener');
  }

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</span>
</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;documentElement.setAttribute("data-header-transparent", "");var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>


























































































































































<style>
    html .page-banner {
      background: #000;
    }
  </style>
<style>html .page-banner {
      height:  36.8vh;
      min-height: 38vh;
    }
    html[data-scroll-status="top"] .page-banner {
      height: 100vh;
    }
  </style>
<style>
    html .page-banner .page-banner-img > *:first-child {
      opacity: 0.618;
    }

    html[data-theme="dark"] .page-banner .page-banner-img > *:first-child {
      opacity: 0.443724;
    }
  </style>
<style>
    html .page-banner .page-banner-inner > *:first-child > *:nth-child(1) {
      font-size: 3.25em; font-weight: bold; text-decoration: underline
    }
  </style>
<style>
    html .page-banner .page-banner-inner > *:first-child > *:nth-child(2) {
      color: gold
    }
  </style>
<section class="page-banner">
    <div class="page-banner-img">
<div style="background-image: url(/jekyll-theme-yat/assets/images/banners/node_js.png)"></div>
        <img class="img-placeholder" src="/jekyll-theme-yat/assets/images/banners/node_js.png">
</div>
    <div class="wrapper">
      <div class="page-banner-inner">
<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">[Node.js] 개념 이해하기</h1>
  <h2 class="post-subtitle"></h2>

  <p class="post-meta">
    <time class="dt-published" datetime="2021-12-07T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Dec 07, 2021
    </time>

    
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 9 mins</span>
  </p>
<div class="post-tags">
<a class="post-tag" href="/jekyll-theme-yat/tags.html#Node.js">#Node.js</a><a class="post-tag" href="/jekyll-theme-yat/tags.html#Javascript">#Javascript</a>
</div></header>
</div>
    </div>
  </section><script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h2 id="nodejs란"><strong>Node.js란</strong></h2>

<hr>

<ul>
  <li>Node.js는 Chrome V8 JavaScript 엔진으로 빌드 된 JavaScript 런타임입니다.</li>
  <li>Node.js는 이벤트 기반, 논 블로킹 I/O 모델을 사용해 가볍고 효율적입니다.</li>
  <li>Node.js의 패키지 생태계인 npm은 세계에서 가장 큰 오픈 소스 라이브러리 생태계이기도 합니다.</li>
</ul>

<p><br></p>

<h2 id="nodejs는-백엔드-vs-프론트엔드-"><strong>Node.js는 백엔드 vs 프론트엔드 ?</strong></h2>

<hr>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">JavaScript 런타임(runtime)</code>을 이해 할 필요가 있다. <code class="language-plaintext highlighter-rouge">런타임(runtime)</code>이란 특정 언어로 만든 프로그램을 실행시킬 수 있는 환경을 뜻한다.</li>
  <li>즉, <code class="language-plaintext highlighter-rouge">Node.js</code>는 <code class="language-plaintext highlighter-rouge">javaScript</code> 한 가지 언어로 <code class="language-plaintext highlighter-rouge">Serve</code>r와 <code class="language-plaintext highlighter-rouge">Client</code>를 모두 구현할 수 있는 환경을 제공하는 백엔드이다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">JavaScript</code>는 java, python 등과 같은 독립적인 언어가 아닌 스크립트 언어입니다.</li>
  <li>스크립트 언어는 웹 브라우저 환경에서만 돌아가기 때문에 웹 브라우저가 없으면 사용할 수 없었습니다.</li>
  <li>하지만! <code class="language-plaintext highlighter-rouge">Node.js</code>가 탄생하게 되면서 <code class="language-plaintext highlighter-rouge">JavaScript</code>를 독립적인 언어로 사용할 수 있게 되었습니다.</li>
</ul>

<p><br></p>

<h2 id="javascript-런타임이란"><strong>JavaScript 런타임이란?</strong></h2>

<hr>

<ul>
  <li>런타임이란, 프로그래밍 언어가 실행되는 환경을 말합니다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">JavaScript</code> 런타임이란, <code class="language-plaintext highlighter-rouge">JavaScript</code>가 실행되는 환경을 말합니다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">JavaScript</code> 런타임은 기본적으로 웹 브라우저입니다.(현재 Node.js 추가)</li>
  <li>
<code class="language-plaintext highlighter-rouge">Node.js</code>가 나타난 뒤로 웹 브라우저 없이도 <code class="language-plaintext highlighter-rouge">JavaScript</code>를 실행시킬 수 있습니다.</li>
</ul>

<p><br></p>

<h2 id="chrome-v8-엔진이란"><strong>Chrome V8 엔진이란?</strong></h2>

<hr>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">v8</code>은 오픈 소스 자바스크립트 엔진입니다.</li>
  <li>구글 크롬 브라우저와 안드로이드 브라우저에 탑재되어 있습니다.</li>
  <li>ECMAScript(ECMA - 262) 3rd Edition 규격의 <code class="language-plaintext highlighter-rouge">C++</code>로 작성되었으며, 독립적으로 실행이 가능합니다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">V8</code>은 자바스크립트를 바이트코드(bytecode)로 컴파일하고 실행하는 방식을 사용한다.(JIT 컴파일)</li>
</ul>

<p>V8엔진이 나온 가장 큰 배경은 JavaScript <code class="language-plaintext highlighter-rouge">속도개선</code> 입니다. <code class="language-plaintext highlighter-rouge">JavaScript</code>는 인터프리터 방식으로 구동됩니다.</p>

<p>우선, <code class="language-plaintext highlighter-rouge">인터프리터(Interpreter)</code> 방식과 <code class="language-plaintext highlighter-rouge">컴파일러(Compiler)</code> 방식이 무엇인지 알아야겠죠?<br>
컴퓨터는 기본적으로 기계어만 이해할 수 있도록 만들어졌습니다. 따라서 어셈블리어나 고급언어로 작성된 코드들은 컴퓨터가 이해할 수 있는 기계어로 번역되어야 컴퓨터에서 실행됩니다.</p>

<p>고급언어로 작성된 원시 프로그램을 기계어로 변역하는 방식은 <code class="language-plaintext highlighter-rouge">컴파일러(Compiler)</code> 방식과 <code class="language-plaintext highlighter-rouge">인터프리터(Interpreter)</code> 방식으로 구분됩니다.</p>

<p><br></p>

<h3 id="컴파일러-방식"><strong>컴파일러 방식</strong></h3>
<ul>
  <li>고급언어로 작성된 코드 전체를 런타임 이전에 기계어로 변환해 주는 방식을 말합니다.</li>
  <li>런타인 이전에 전체 코드를 기계어로 변환하기 때문에 시간이 오래 걸립니다.</li>
  <li>런타임 이전에 전체 코드를 해석하여 기계어로 전환되기 때문에 OS 및 빌드환경에 종속적입니다.</li>
  <li>대표적으로, <code class="language-plaintext highlighter-rouge">C</code>, <code class="language-plaintext highlighter-rouge">C++</code>이 있습니다.</li>
  <li>구동시 시스템으로부터 <code class="language-plaintext highlighter-rouge">메모리</code>를 할당받으며, 할당받은 메모리를 사용합니다.</li>
</ul>

<p><br></p>

<h3 id="인터프리터-방식"><strong>인터프리터 방식</strong></h3>
<ul>
  <li>컴파일러 방식과 반대로 런타임 이후에 코드를 한 줄 씩 해석하여 실행시키는 방식을 말합니다.</li>
  <li>한 줄씩 해석-&gt;번역-&gt;실행 하기 때문에 수정한 내용이 바로 반영되는 장점이 있습니다.</li>
  <li>고급언어를 기계어로 바로 번역하지않고 런타임 이후에 해석-&gt;실행 하기 때문에 컴파일러 방식보다 속도가 느립니다.</li>
  <li>메모리를 별도로 할당받지 않기 때문에, 필요시 따로 할당해야합니다.</li>
  <li>대표적으로 <code class="language-plaintext highlighter-rouge">JavaScript</code>, <code class="language-plaintext highlighter-rouge">python</code>이 있습니다.</li>
</ul>

<p><br></p>

<p>다시 본론으로 돌아와서 <code class="language-plaintext highlighter-rouge">JavaScript</code>는 인터프리터 방식으로 구동되기 때문에, 코드가 많아 질수록 속도가 느려지는 단점이 있습니다.<br>
<code class="language-plaintext highlighter-rouge">V8</code> 엔진은 느린 속도를 개선하고자 인터프리터 방식이 아닌 <code class="language-plaintext highlighter-rouge">JIT(Just-In-Time)컴파일러</code>를 적용하여 단점을 보완했습니다.</p>

<p><br></p>

<h3 id="jitjust-in-time컴파일러"><strong>JIT(Just-In-Time)컴파일러</strong></h3>
<ul>
  <li>실행 시점에서 인터프리트 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지합니다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">JIT(Just-In-Time)컴파일러</code>는 인터프리터 방식의 단점을 보완하기 위해 도입되었습니다.</li>
  <li>다시말해, 실행시점에 인터프리터 방식으로 기계어 코드를 생성해서 캐시에 저장해 두었다가, 재사용시 컴파일을 다시 할 필요 없이 사용할 수 있습니다.</li>
  <li>인터프리터 언어는 바이트코드나 소스코드를 최적화 과정 없이 변역하기 때문에 성능이 낮고, 정적 언어는 실행 전에 무조건 컴파일 해야하기 때문에 다양한 플랫폼에 맞게 컴파일 하려면 시간이 오래 걸립니다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">JIT(Just-In-Time)컴파일러</code>는 정적 컴파일러 만큼 속도가 빠르고, 인터프리터 언어의 빠른 응답속도를 추구하기 위해 만들어 졌습니다. 즉, 컴파일러 방식과 인터프리터 방식을 혼합해 만들었습니다.</li>
</ul>

<p><br></p>

<h2 id="이벤트-기반-비동기-방식"><strong>이벤트 기반 비동기 방식</strong></h2>

<hr>

<p>클라이언트의 요청이 많은 서버의 경우 병목 현상이 발생하게 됩니다. 병목현상의 주 원인은 프로그램 로직보다는 입출력(I/O)에서 발생하게 됩니다. 
통계자료에 따르면 I/O에 소요되는 비용 중 가장 많이 소요되는 비용은 <code class="language-plaintext highlighter-rouge">Network</code>와 <code class="language-plaintext highlighter-rouge">Disk</code> 라고 합니다.</p>

<p>서버에서 <code class="language-plaintext highlighter-rouge">I/O</code>를 처리하다가 지연이 발생하면 다른 요청들을 처라히지 못하고 계속 대기하게 되는데 이런 현상을 <code class="language-plaintext highlighter-rouge">병목현상</code>이라 합니다.
그렇기 때문에, 대부분의 기업들이 멀티 쓰레드 기반으로 사용자들의 요청을 처리하고 있습니다.</p>

<p>멀티 쓰레드 방식은 요청이 올때마다 쓰레드를 발생시켜 처리합니다. 만약 동시에 대규모의 요청이 들어오게 되면 이에 대응되는 많은 쓰레드를 발생시키게 되는데 이는 많은 자원을 소모하게 됩니다.
서버의 자원은 무한하지 않기 때문에 제한을 받게 됩니다.</p>

<p>이런 문제들 때문에 이벤트 기반, <code class="language-plaintext highlighter-rouge">Non-Blocking I/O</code>모델을 사용하는 <code class="language-plaintext highlighter-rouge">Node.js</code>가 사랑받고 있는 것 같습니다.</p>

<p>이벤트 기반 비동기 방식을 이해하기 전에 아래의 내용을 이해하는게 중요합니다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Blocking I/O</code></li>
  <li><code class="language-plaintext highlighter-rouge">Non-Blocking I/O</code></li>
  <li><code class="language-plaintext highlighter-rouge">프로세스</code></li>
  <li><code class="language-plaintext highlighter-rouge">프로그램</code></li>
  <li><code class="language-plaintext highlighter-rouge">스레드</code></li>
  <li><code class="language-plaintext highlighter-rouge">멀티스레드</code></li>
  <li><code class="language-plaintext highlighter-rouge">비동기 처리</code></li>
</ol>

<p><br></p>

<h3 id="blocking-io"><strong>Blocking I/O</strong></h3>

<p>대부분의 프로그램은 <code class="language-plaintext highlighter-rouge">Blocking I/O</code> 모델을 사용합니다. 
<code class="language-plaintext highlighter-rouge">Blocking I/O</code>란 어떤 프로세스가 어떤 자원을 점유해 사용하고 있다면, 다른 프로세스는 해당 자원이 끝날 때 까지 대기해야 사용할 수 있습니다.</p>

<p>예를들어</p>
<ol>
  <li>어플레케이션 -&gt; 운영체제(커널) 파일 읽기를 요청</li>
  <li>운영체제(커널) I/O 처리 시작 -&gt; 다른 프로세스가 이미 사용중 -&gt; 대기</li>
  <li>대기가 끝나고 I/O처리 완료 -&gt; 파일 읽기에 대해 응답</li>
</ol>

<p>2번을 보면, 대기 부분이 어플리케이션 입장에서는 <code class="language-plaintext highlighter-rouge">Blocked(대기)</code>이며, 응답이 올 때까지 아무것도 못하는 상태가 됩니다.</p>

<p><br></p>

<h3 id="non-blocking-io"><strong>Non-Blocking I/O</strong></h3>

<p><code class="language-plaintext highlighter-rouge">Blocking</code> 모델과는 반대로 I/O 작업이 진행되고 있더라도 해당 유저 프로세스의 작업을 중단시키기 않습니다.</p>

<p>예를들어</p>
<ol>
  <li>어플레케이션 -&gt; 운영체제(커널) 파일 읽기를 요청</li>
  <li>운영체제(커널) I/O 처리 시작 -&gt; 다른 프로세스가 이미 사용중 -&gt; 데이터가 없어도 일단 응답</li>
  <li>1,2 번 반복 후 데이터가 있으면 -&gt; 결과 응답</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">Blocking I/O</code>와는 다르게 I/O의 진행상황에 상관없이 대기하지 않습니다. 하지만 결과를 응답하기 위해 반복적인 호출을 하기 때문에 자원이 낭비됩니다.</p>

<p><br></p>

<h3 id="프로세스"><strong>프로세스</strong></h3>
<p><a href="https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4">위키백과 : 프로세스</a></p>

<p><code class="language-plaintext highlighter-rouge">프로세스</code>는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말합니다. 종종 스케줄링의 대상이 되는 <code class="language-plaintext highlighter-rouge">작업(Task)</code>이라는 용어와 거의 같은 의미로 쓰입니다. 여러 개의 프로세서를 사용하는 것을 <code class="language-plaintext highlighter-rouge">멀티프로세싱</code>이라고 하며, 같은 시간에 여러 개의 프로그램을 띄우는 시분할 방식을 <code class="language-plaintext highlighter-rouge">멀티태스킹</code>이라고 합니다.</p>

<p>프로그램과 프로세스를 혼동할 수 있는데,</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">프로그램</code>은 일반적으로 <code class="language-plaintext highlighter-rouge">하드 디스크</code>에 저장되어 있는 실행코드(파일)를 말합니다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">프로세스</code>는 프로그램을 구동하여 프로그램 자체와 프로그램의 상태가 메모리 상에 실행되고 있는 작업 단위를 지칭합니다.</li>
  <li>하나의 프로그램을 여러 번 구동하게 되면 여러 개의 프로세스가 메모라 상에서 실행됩니다.</li>
</ul>

<p><br></p>

<h3 id="스레드"><strong>스레드</strong></h3>
<p><a href="https://ko.wikipedia.org/wiki/%EC%8A%A4%EB%A0%88%EB%93%9C_(%EC%BB%B4%ED%93%A8%ED%8C%85)">위키백과 : 스레드</a></p>

<p><code class="language-plaintext highlighter-rouge">스레드(Thread)</code>는 어떠한 프로그램 내에서, 특히 <code class="language-plaintext highlighter-rouge">프로세스</code> 내에서 실행되는 흐름의 단위를 말한다. 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행할 수 있다. 이러한 실행 방식을 <code class="language-plaintext highlighter-rouge">멀티스레드(multithread)</code>라고 한다.</p>

<p><br></p>

<h3 id="프로세스-vs-스레드"><strong>프로세스 vs 스레드</strong></h3>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">멀티프로세스</code>와 <code class="language-plaintext highlighter-rouge">멀티스레드</code> 둘다 여러 흐름이 동시에 진행된다는 공통점을 가지고 있습니다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">멀티프로세스</code>에서 각 프로세스는 독립적으로 실행되며, 각각 별개의 메모리를 차지하고 있는 것과 달리 <code class="language-plaintext highlighter-rouge">멀티스레드</code>는 프로세스 내의 메모리를 공유해 사용할 수 있습니다.</li>
  <li>프로세스 간의 전환 속도 보다 스레드 간의 전확 속도가 빠릅니다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">멀티스레드</code>는 CPU가 여러 개일 경우에 각각의 CPU가 스레드 하나씩을 담당하는 방법으로 속도를 높일 수 있다는 장점을 가지고 있습니다.</li>
  <li>그게 가능한 이유는 여러 스레드가 실제 시간상으로 동시에 수행될 수 있기 때문입니다.</li>
  <li>하지만, <code class="language-plaintext highlighter-rouge">멀티스레드</code>의 단점은 각각의 스레드 중 어떤 것이 먼저 실행될지 그 순서를 알 수 없다는 것입니다.</li>
</ul>

<p><br></p>

<h3 id="멀티-스레드"><strong>멀티 스레드</strong></h3>
<p><a href="https://ko.wikipedia.org/wiki/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9">위키백과 : 스레드</a></p>

<p><code class="language-plaintext highlighter-rouge">멀티스레딩(multithreading)</code> 컴퓨터는 여러 개의 스레드를 효과적으로 실행할 수 있는 하드웨어 지원을 갖추고 있다. 이는 스레드가 모두 같은 주소 공간에서 동작하여 하나의 CPU 캐시 공유 집합과 하나의 변환 색인 버퍼 (TLB)만 있는 멀티프로세서 시스템 (멀티 코어 시스템)과는 구별한다. 그러므로 멀티스레딩은 프로그램 안에서 병렬 처리의 이점을 맛볼 수 있지만 멀티프로세싱 시스템은 여러 개의 프로그램들을 병렬로 처리할 수 있다. 멀티프로세싱 시스템이 여러 개의 완전한 처리 장치들을 포함하는 반면 멀티스레딩은 스레드 수준뿐 아니라 명령어 수준의 병렬 처리에까지 신경을 쓰면서 하나의 코어에 대한 이용성을 증가하는 것에 초점을 두고 있다.</p>

<p>정리하여</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">프로세스</code>를 다수의 실행 단위로 나누어서 실행합니다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">프로세스</code> 내에서 자원을 공유하며, 자원생성과 관리의 중복을 최소화합니다.</li>
  <li>각각의 스레드가 고유의 레지스터와 스택을 사용합니다.</li>
</ul>

<h3 id="멀티-스레드의-장단점"><strong>멀티 스레드의 장단점</strong></h3>

<p><strong>장점</strong></p>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">응답성</code> : 일부분의 레드가 중단되거나 긴 작업을 수행하더라도 프로그램의 수행이 계속되어, 사용자에 대한 응답성이 증가됩니다. 예를 들어 웹 브라우저 프로그램에서 하나의 스레드가 이미지 파일을 로드하고 있더라도, 다른 스레드에 사용자와의 상호작용이 가능합니다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">자원 공유</code> : 프로세스의 자원들과 메모리를 공유합니다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">경제성</code> : 프로세스 생성에 메모리와 자원을 할당하는 것은 비용이 많이 든다. 스레드는 자신이 속한 프로세스의 자원들을 공유하기 때문에, 스레드를 생성하고 문맥교환을 하는 편이 보다 경제적입니다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">멀티프로세서 활용</code> : 멀티프로세서 구조에서는 각각의 스레드가 다른 프로세서에서 병렬로 수행될 수 있다. 단일 스레드 프로세스는 CPU가 많아도 CPU 한개에서만 실행된다. 즉, 다중 스레드화를 하면 다중 CPU에서 병렬성이 증가된다.</li>
</ul>

<p><strong>단점</strong></p>
<ul>
  <li>같은 자원을 <code class="language-plaintext highlighter-rouge">공유</code>할 때 서로를 <code class="language-plaintext highlighter-rouge">간섭</code>할 수 있다.</li>
  <li>멀티스레드 프로세스에서, 하나의 스레드만 실행 중인 경우 스레드의 실행 시간이 개선되지 않고 오히려 <code class="language-plaintext highlighter-rouge">지연</code>될 수 있다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">멀티스레딩</code>의 하드웨어 지원을 위해 응용 프로그램과 운영체제 둘 다 충분한 변화가 필요하다.</li>
  <li>스레드 스케줄링은 멀티스레딩의 주요 문제이기도 하다.</li>
</ul>

<p><strong>한계</strong></p>

<p>멀티스레드 방식은 요청마다 스레드를 발생시켜 처리한다고 말씀드렸죠? 이런 방식은 <code class="language-plaintext highlighter-rouge">IO Blocking</code> 모델을 해결하는 이상적인 방법으로 보일 수 있습니다. 하지만 몇 가지 한계도 존재합니다.</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">멀티스레드</code> 방식은 클라이언트 요청 마다 스레드를 발생시키기 때문에, 요청 수가 많으면 많을수록 스레드 수도 기하급수적으로 발생하게 됩니다. 그 만큼 메모리 자원을 사용한다는 말입니다. 하지만, 서버의 자원은 제한적이기 때문에 일정 수 이상의 스레드를 발생시킬 수 없습니다.</li>
  <li>위의 근본적인 문제때문에 실제로, 서버의 사양을 업그레이드 시키거나 <code class="language-plaintext highlighter-rouge">Load-Balancing</code> 등으로 분산처리하여 해결하고 있습니다.</li>
</ul>

<p><br></p>

<h3 id="비동기-처리"><strong>비동기 처리</strong></h3>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">Node.js</code>의 비동기 처리에 대해 잘 설명한 블로그를 참고</li>
</ul>

<p>참고자료 : <a href="https://www.nextree.co.kr/p7292/">Node.js: 비동기 프로그래밍 이해</a></p>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/jekyll-theme-yat/tdd/2021/12/06/TDD.html" title="TDD란 무엇이고, 왜 많은 기업에서 TDD 방식을 선호하지 않을까?">TDD란 무엇이고, 왜 많은 기업에서 TDD...</a><a class="next" href="/jekyll-theme-yat/javascript/2021/12/07/javascript-01.html" title="[Javascript] ECMAScript?, ES6? 개념 이해">[Javascript] ECMAScript?, ES6? 개념 이해</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li><a class="post-link" href="/jekyll-theme-yat/node.js/2022/02/09/Node.js-04.html" title="[Javascript] ECMAScript?, ES6? 개념 이해">[Node.js] Express API 서버 구축 - 앱 구조화 및 기본 라우팅</a></li>
<li><a class="post-link" href="/jekyll-theme-yat/babel/2021/12/28/Babel-03.html" title="[Javascript] ECMAScript?, ES6? 개념 이해">[Babel] Webpack에 통합하여 사용하기</a></li>
<li><a class="post-link" href="/jekyll-theme-yat/javascript/2022/05/12/javascript-14.html" title="[Javascript] ECMAScript?, ES6? 개념 이해">[Javascript] 함수형 프로그래밍 - go, pipe, curry</a></li>
<li><a class="post-link" href="/jekyll-theme-yat/web/2022/01/19/web-Autorization.html" title="[Javascript] ECMAScript?, ES6? 개념 이해">[Web] 서버 인증방식 Cookie, Session, Token</a></li>
</ul>
    </div>
<div class="post-comments"></div></section>
</div>
<script>
  new Zooming().listen('img')
</script>

  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/jekyll-theme-yat/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div>
<span class="copyleft">©</span> 2022 Seo SeongSik. All rights reserved</div>
      <div>Go to <a title="github" href="https://github.com/s-seongsik">Github</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
