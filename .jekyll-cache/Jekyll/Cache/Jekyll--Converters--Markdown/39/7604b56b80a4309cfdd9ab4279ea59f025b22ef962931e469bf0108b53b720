I"s<p>ES6(2015) 이전에는 자바스크립트에서 변수를 선언할 수 있는 방법은 <code class="language-plaintext highlighter-rouge">var</code>뿐이었습니다.</p>

<p>이것은 많은 문제를 발생시켰습니다.</p>

<ol>
  <li>전역 변수로 인한 스코프 충돌
    <ul>
      <li>ES6이전에 스코프는 <code class="language-plaintext highlighter-rouge">전역 스코프(Global Scope)</code> 와 <code class="language-plaintext highlighter-rouge">함수 스코프(Function Scope)</code>만 있었습니다. 자바스크립트는 함수 스코프 외에는 모두 전역 스코프로 적용되기 때문에 전역 변수를 남발하여 스코프 충돌의 문제를 발생시켰습니다.</li>
    </ul>
  </li>
  <li>변수 중복 선언
    <ul>
      <li>자바스크립트의 코드양이 많으면 많을 수록 스코프 충돌의 문제를 발생시킵니다. 이미 선언된 변수를 또 <code class="language-plaintext highlighter-rouge">재선언</code>을 하거나 <code class="language-plaintext highlighter-rouge">다른 값을 넣거나</code>하는 문제를 발생할 수 있습니다.</li>
    </ul>
  </li>
</ol>

<p>보통 <code class="language-plaintext highlighter-rouge">전역변수</code>로 인해 발생하는 문제로, 이를 해결하고자 ES6(2015)부터는 <code class="language-plaintext highlighter-rouge">let</code>과 <code class="language-plaintext highlighter-rouge">const</code> Keyword를 도입했습니다.</p>

<p><br /></p>

<h2 id="a"><strong>let</strong></h2>

<hr />

<p><code class="language-plaintext highlighter-rouge">ES6(2015)</code>이전의 자바스크립트는 함수 내에서 선언된 변수 외 모든 코드 블록 내에서 선언된 변수는 <code class="language-plaintext highlighter-rouge">전역 스코프(Global Scope)</code>를 갖습니다.</p>

<h3 id="b"><strong>Block Scope</strong></h3>

<p><strong>ES6(2015) 이전</strong></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

  <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">change</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</code></pre></div></div>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">  change
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">x</code>에 10을 넣었지만, { } 블록 내부에 <code class="language-plaintext highlighter-rouge">x</code>를 재선언 되었기 때문에 <code class="language-plaintext highlighter-rouge">change</code>로 변경되어 출력되었습니다.</p>

<p><br /></p>

<p><strong>ES6(2015) let Keyword</strong></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

  <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">change</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</code></pre></div></div>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">  10
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">{ }</code> 코드 내부에 선언된 <code class="language-plaintext highlighter-rouge">x</code>는 <code class="language-plaintext highlighter-rouge">블록 스코프</code>를 따르기 때문에 외부에서 접근할 수 없습니다. 즉 재선언이 안된다는 말이죠.
따라서 전역 변수로 선언한 <code class="language-plaintext highlighter-rouge">x=10</code>이 출력되는 것을 확인할 수 있습니다.</p>

<p><br /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Global</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// 전역 변수</span>

  <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">x Local</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// 지역 변수</span>
    <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">y Local</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// 지역 변수</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// Global</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span> <span class="c1">// ReferenceError: bar is not defined</span>
</code></pre></div></div>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">  Global
</span></code></pre></div></div>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">  Uncaught ReferenceError: y is not defined
</span><span class="gp">    at &lt;anonymous&gt;</span>:9:13
</code></pre></div></div>

<p>전역 스코프를 갖는 <code class="language-plaintext highlighter-rouge">let x='Global'</code>는 <code class="language-plaintext highlighter-rouge">{ }</code> 코드 내부에 선언한 <code class="language-plaintext highlighter-rouge">let x = 'x Local'</code>로 재선언되지 않으며
<code class="language-plaintext highlighter-rouge">y</code>는 <code class="language-plaintext highlighter-rouge">블록 스코프</code>를 따르기 때문에 외부에서 접근할 수 없기 때문에 <code class="language-plaintext highlighter-rouge">console.log</code>시 <code class="language-plaintext highlighter-rouge">ReferenceError</code> 오류를 확인할 수 있습니다.</p>

<p><br /></p>

<h3 id="c"><strong>재선언 금지</strong></h3>

<p><code class="language-plaintext highlighter-rouge">var</code> 키워드는 동일한 이름을 갖는 변수를 몇 번이고 <code class="language-plaintext highlighter-rouge">재선언</code>을 할 수 있습니다. 하지만 <code class="language-plaintext highlighter-rouge">let</code> 키워드는 동일한 이름으로 <code class="language-plaintext highlighter-rouge">재선언</code>을 할 수 없습니다.
중복 선언하게 되면 <code class="language-plaintext highlighter-rouge">문법 에러(SyntaxError)</code>를 발생시킵니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 최초 선언</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// 재 선언</span>

  <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 최초 선언</span>
  <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// 재 선언</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
</code></pre></div></div>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">  Uncaught SyntaxError: Identifier 'y' has already been declared
</span></code></pre></div></div>

<p><br /></p>

<h3 id="d"><strong>호이스팅</strong></h3>

<p>자바스크립트에서 선언된 모든 것(<code class="language-plaintext highlighter-rouge">var</code>, <code class="language-plaintext highlighter-rouge">let</code>, <code class="language-plaintext highlighter-rouge">const</code>, <code class="language-plaintext highlighter-rouge">function</code>, <code class="language-plaintext highlighter-rouge">class</code>)을 호이스팅이라고 합니다. 
호이스팅(Hoisting)이란, <code class="language-plaintext highlighter-rouge">var</code> 선언문이나 <code class="language-plaintext highlighter-rouge">function</code> 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성을 말한다.</p>

<p><code class="language-plaintext highlighter-rouge">예시</code>를 먼저 보겠습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
</code></pre></div></div>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">  undefined
</span></code></pre></div></div>

<p>변수 <code class="language-plaintext highlighter-rouge">x</code>를 선언하기 전에 <code class="language-plaintext highlighter-rouge">console.log</code>로 출력을 했는데 <code class="language-plaintext highlighter-rouge">x is not defined</code> 오류가 발생하지 않았습니다. 왜 그런지 알아봅시다.</p>

<p>변수는 3단계를 걸쳐 생성됩니다.</p>

<p>1단계: <code class="language-plaintext highlighter-rouge">선언 단계(Declaration phase)</code></p>
<ul>
  <li>변수를 실행 컨텍스트의 변수 객체(Variable Object)에 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다.</li>
</ul>

<p>2단계: <code class="language-plaintext highlighter-rouge">초기화 단계(Initialization phase)</code></p>
<ul>
  <li>변수 객체(Variable Object)에 등록된 변수를 위한 공간을 메모리에 확보한다. 이 단계에서 변수는 undefined로 초기화된다.</li>
</ul>

<p>3단계: <code class="language-plaintext highlighter-rouge">할당 단계(Assignment phase)</code></p>
<ul>
  <li>undefined로 초기화된 변수에 실제 값을 할당한다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">var</code>는 <code class="language-plaintext highlighter-rouge">선언 단계</code>와 <code class="language-plaintext highlighter-rouge">초기화 단계</code>가 한 번에 실행됩니다. 스코프에 변수를 <code class="language-plaintext highlighter-rouge">등록(선언 단계)</code>하여 메모리에 공간을 확보한 뒤,
<code class="language-plaintext highlighter-rouge">undefined</code>로 <code class="language-plaintext highlighter-rouge">초기화(초기화 단계)</code>합니다. 이러한 이유로 변수선언문 이전에 변수에 접근하여도 에러가 발생하지 않고 <code class="language-plaintext highlighter-rouge">undefined</code>를 반환한 것입니다.
이후 변수에 값을 <code class="language-plaintext highlighter-rouge">할당(할당 단계)</code>해야 비로소 값이 할당 되는 것입니다. 이런 현상을 변수 호이스팅(Variable Hoisting)이라 합니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 스코프의 선두에서 선언 단계와 초기화 단게가 한 번에 이루어 집니다.</span>
  <span class="c1">// 따라서, 변수 선언 이전에 변수에 참조할 수 있습니다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>  <span class="c1">// undefined</span>

  <span class="kd">var</span> <span class="nx">x</span><span class="p">;</span>           <span class="c1">// 선언 단계</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>  <span class="c1">// undefined</span>

  
  <span class="nx">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>          <span class="c1">// 할당 단계</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>  <span class="c1">// 10</span>
</code></pre></div></div>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">  undefined
  undefined
  10
</span></code></pre></div></div>

<p><br /></p>

<p><strong>let은 선언 단계와 초기화 단계가 분리되어 진행합니다.</strong></p>

<p>let은 스코프에 변수를 등록(선언단계)은 하지만 초기화 단계는 변수 선언문에 도달했을 때 실행합니다. 따라서 초기화 이전에 변수에 접근하려고 하면 <code class="language-plaintext highlighter-rouge">참조 에러(ReferenceError)</code>가 발생합니다.
그 이유는 초기화 단게가 이루어지지 않았기 때문입니다. 즉, 변수를 담을 메모리 공간이 확보되지 않았기 때문입니다. 
정리해서 스코프의 시작 지점부터 초기화 시작 지점까지는 변수를 참조할 수 없습니다. 이 구간을 <code class="language-plaintext highlighter-rouge">일시적 사각지대(Temporal Dead Zone; TDZ)</code>라고 부릅니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 스코프의 선두에서 선언 단계가 이루어집니다.</span>
  <span class="c1">// 변수 초기화 단계는 이루어지지 않았습니다.</span>
  <span class="c1">// 따라서, 변수 선언 이전에 변수에 참조할 수 없습니다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>  <span class="c1">// Uncaught ReferenceError: x is not defined</span>

  <span class="kd">let</span> <span class="nx">x</span><span class="p">;</span>           <span class="c1">// 선언 단계</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>  <span class="c1">// undefined</span>

  
  <span class="nx">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>          <span class="c1">// 할당 단계</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>  <span class="c1">// 10</span>
</code></pre></div></div>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">  Uncaught ReferenceError: x is not defined
</span><span class="gp">    at &lt;anonymous&gt;</span>:3:15
</code></pre></div></div>

<p><br /></p>

<p>그럼 let은 호이스팅이 안되는게 아닐까?</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

  <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></div>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">  10
</span></code></pre></div></div>

<p>결과를 보면 <code class="language-plaintext highlighter-rouge">선언단계</code>와 <code class="language-plaintext highlighter-rouge">초기화단계</code>가 먼저 이루어졌기 때문에 정상적으로 결과값이 출력됩니다.</p>

<p><br /></p>

<p>아래 코드에 <code class="language-plaintext highlighter-rouge">let</code> 선언을 추가해봅니다.</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

  <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
      <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">  Uncaught ReferenceError: Cannot access 'x' before initialization
</span></code></pre></div></div>

<p>전역변수 <code class="language-plaintext highlighter-rouge">x</code>가 <code class="language-plaintext highlighter-rouge">console.log</code>에 출력될 것 처럼 보일 수 있다. 하지만, <code class="language-plaintext highlighter-rouge">{ }</code> 블록안에서 호이스팅이 발생하기 때문에 <code class="language-plaintext highlighter-rouge">참조 에러(ReferenceError)</code>가 발생하게 됩니다.</p>

<p><code class="language-plaintext highlighter-rouge">ES6</code>의 <code class="language-plaintext highlighter-rouge">let</code>과 <code class="language-plaintext highlighter-rouge">const</code> 키워드는 코드블록 내에서는 블록 스코프를 따르므로 <code class="language-plaintext highlighter-rouge">{ }</code>블록 내에 선언 된 <code class="language-plaintext highlighter-rouge">let x</code>는 지역 변수로 적용됩니다. 따라서 <code class="language-plaintext highlighter-rouge">{ }</code> 블록 안 스코프에서 호이스팅이 적용되고 코드 블록의 선두에서 초기화가 이루어 지는 지점까지는 <code class="language-plaintext highlighter-rouge">일시적 사각지대(TDZ)</code>에 빠지게 됩니다. 그렇기 때문에 <code class="language-plaintext highlighter-rouge">참조 에러(ReferenceError)</code>가 발생하게 됩니다.</p>

<p><br /></p>

<h3 id="let은-전역-객체가-아니다"><strong>let은 전역 객체가 아니다</strong></h3>

<p id="e"><code class="language-plaintext highlighter-rouge">전역 객체(Global Object)</code>란 모든 객체의 최상위 객체를 의미합니다.</p>

<p>Browser-side에서는 <code class="language-plaintext highlighter-rouge">window 객체</code>, Server-side(Node.js)에서는 <code class="language-plaintext highlighter-rouge">global 객체</code>를 의미합니다.</p>

<p>여기서 <code class="language-plaintext highlighter-rouge">var</code>로 선언된 변수를 전역 변수로 사용하게 된다면 <code class="language-plaintext highlighter-rouge">전역 객체</code>의 프로퍼티가 됩니다.</p>

<p>하지만, <code class="language-plaintext highlighter-rouge">let</code>로 선언된 변수를 전역 변수로 사용하게 되더라도 <code class="language-plaintext highlighter-rouge">전역 객체</code>의 프로퍼티가 아닙니다.</p>

<p>다시말해, <code class="language-plaintext highlighter-rouge">window 객체</code>로 접근할 수 없으며, <code class="language-plaintext highlighter-rouge">global 객체</code>에만 접근할 수 있습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Global Object</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// var 키워드 선언</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>   <span class="c1">// var 키워드는 전역 객체(Global Object)의 프로퍼티가 되므로 window 객체 접근 가능</span>
</code></pre></div></div>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">  Global Object
</span></code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Global Object</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// let 키워드 선언</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>  <span class="c1">// let 키워드는 전역 객체(Global Object)의 프로퍼티가 되므로 window 객체 접근 불가능</span>
</code></pre></div></div>
<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">  undefined
</span></code></pre></div></div>

<p><br /></p>

<h2 id="f"><strong>const</strong></h2>

<hr />

<p><code class="language-plaintext highlighter-rouge">const</code>는 상수(변하지 않는 값)을 위해 사용하는 키워드입니다.</p>

<p><code class="language-plaintext highlighter-rouge">const</code>는 <code class="language-plaintext highlighter-rouge">let</code>과 대부분 비슷하지만 다른점에 대해서만 알아보겠습니다.</p>

<p><br /></p>

<h3 id="선언과-초기화"><strong>선언과 초기화</strong></h3>

<p id="g"><code class="language-plaintext highlighter-rouge">let</code> 의 특징</p>
<ul>
  <li>중복선언 불가능
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">x</span><span class="o">=</span><span class="mi">20</span><span class="p">;</span>  <span class="c1">// 최초 선언</span>
<span class="kd">let</span> <span class="nx">x</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>  <span class="c1">// 중복 선언</span>
</code></pre></div>    </div>
    <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">Uncaught SyntaxError: Identifier 'x' has already been declared
</span></code></pre></div>    </div>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>재할당 가능
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">x</span><span class="o">=</span><span class="mi">30</span><span class="p">;</span>   <span class="c1">// 최초 선언</span>
<span class="nx">x</span> <span class="o">=</span><span class="mi">20</span><span class="p">;</span>      <span class="c1">// 재할당</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// 20 출력 </span>
</code></pre></div>    </div>
    <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">20
</span></code></pre></div>    </div>
    <p><br /></p>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">const</code>의 특징</p>

<ul>
  <li>중복선언 불가능
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">x</span><span class="o">=</span><span class="mi">20</span><span class="p">;</span>  <span class="c1">// 최초 선언</span>
<span class="kd">const</span> <span class="nx">x</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>  <span class="c1">// 중복 선언</span>
</code></pre></div>    </div>
    <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">Uncaught SyntaxError: Identifier 'x' has already been declared
</span></code></pre></div>    </div>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>재할당 불가능
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">x</span><span class="o">=</span><span class="mi">30</span><span class="p">;</span>   <span class="c1">// 최초 선언</span>
<span class="nx">x</span> <span class="o">=</span><span class="mi">20</span><span class="p">;</span>      <span class="c1">// 재할당시 문법 에러 발생</span>
</code></pre></div>    </div>
    <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">Uncaught TypeError: Assignment to constant variable.
</span></code></pre></div>    </div>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">const의 키워드는 반드시 선언과 동시에 할당이 이루어져야 합니다.</code> 그렇지 않으면 이미 선언된 변수에 값을 할당할 수 없습니다. 
그 이유는 재할당이 안되기 때문입니다.
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">x</span><span class="p">;</span>    <span class="c1">// 초기화</span>
<span class="nx">x</span> <span class="o">=</span><span class="mi">20</span><span class="p">;</span>      <span class="c1">// 할당</span>
</code></pre></div>    </div>
    <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">Uncaught SyntaxError: Missing initializer in const declaration
</span></code></pre></div>    </div>
  </li>
</ul>

<p><br /></p>

<h3 id="h"><strong>const의 객체</strong></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">const</code>는 재할당이 되지 않는다고 말씀드렸습니다. 하지만, 객체의 프로퍼티는 변경할 수 있습니다.
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">seongsik</span><span class="dl">'</span><span class="p">};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">good</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
</code></pre></div>    </div>
    <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">{name: 'good'}
</span></code></pre></div>    </div>
  </li>
</ul>

<p>const 키워드는 객체의 내용이 변경(추가, 변경, 삭제)되더라도 객체 타입 변수에 할당된 메모리 주소값은 변경되지 않습니다.
따라서, 객체 타입 변수 선언에는 <code class="language-plaintext highlighter-rouge">const</code>를 사용하는 것이 좋습니다. 만약 객체 타입 변수의 주소값을 변경(재할당)해야 한다면 <code class="language-plaintext highlighter-rouge">let</code>을 사용합니다.</p>

<p><br /></p>

<h2 id="i"><strong>끝으로</strong></h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ES6(2015)+</code>를 사용한다면 <code class="language-plaintext highlighter-rouge">var</code>를 사용하지 않는 것이 좋습니다.</li>
  <li>자바스크립트 코드양이 많아질 수록 의도치 않은 재할당 실수를 하게되는데 이를 방지하기 위해 <code class="language-plaintext highlighter-rouge">const</code>를 사용합니다.</li>
  <li>재할당이 필요한 경우에는 <code class="language-plaintext highlighter-rouge">let</code>을 사용합니다.</li>
</ul>
:ET